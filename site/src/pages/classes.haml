:textile
  h3. Creating classes
  
  Classes are the basic building blocks of many object-oriented systems. JavaScript 1.x
  (a.k.a. ECMAScript 3) does not support classes natively, although it has prototype
  objects and constructor functions that look a lot like classes in terms of syntax.
  Creating class-based programs in JavaScript can be cumbersome, but @JS.Class@ makes
  it easier.
  
  To make a class, you just ask for a @new JS.Class()@, and list the names of the methods
  the class has as regular JavaScript functions.
  
  <pre class="prettyprint">
  var Animal = new JS.Class({
    initialize: function(name) {
      this.name = name;
    },
    
    speak: function(things) {
      return 'My name is ' + this.name + ' and I like ' + things;
    }
  });</pre>
  
  Classes are expected to have an @initialize()@ method, though this is not essential
  if no parameters are used to construct instances. The @initialize()@ method is called
  when you make an instance of the class, and is passed the parameters used to
  instantiate the new object.
  
  <pre class="prettyprint">
  var nemo = new Animal('Nemo');    // nemo.name == "Nemo"
  
  nemo.speak('swimming')
  // -> "My name is Nemo and I like swimming"</pre>
  
  h3. Inheriting from a parent class
  
  Let's say we want to model a more specific kind of animal. We can create a class
  @Dog@ as follows:
  
  <pre class="prettyprint">
  var Dog = new JS.Class(Animal, {
    speak: function(stuff) {
      return this.callSuper().toUpperCase() + '!';
    },
    
    huntForBones: function(garden) {
      // ...
    }
  });</pre>
  
  @Dog@ does not need its own @initialize()@ method as it inherits one from @Animal@. However, it
  chooses to override the @speak()@ method with its own version.
  
  Now we come to a special method generated by @JS.Class@, called @callSuper()@. This method gets
  created dynamically inside method calls and allows you to access the current method in the parent
  class. Like in Ruby, you don't have to pass any arguments to @callSuper()@, thus avoiding repetition.
  The arguments given to the current method are automatically passed by @callSuper()@ up to the
  parent method.
  
  <pre class="prettyprint">
  var rex = new Dog('Rex');
  rex.speak('barking')
  // -> "MY NAME IS REX AND I LIKE BARKING!"</pre>
  
  @callSuper()@ is not accessible from outside the object:
  
  <pre class="prettyprint">
  rex.callSuper();
  // -> rex.callSuper is not a function</pre>
  
  You can pass arguments to @callSuper()@ to override the ones passed in automatically, e.g.:
  
  <pre class="prettyprint">
  var Dog = new JS.Class(Animal, {
    speak: function(stuff) {
      stuff = stuff.replace(/[aeiou]/ig, '_');
      return this.callSuper(stuff).toUpperCase() + '!';
    }
  });
  
  var rex = new Dog('rex');
  rex.speak('something')
  // -> "MY NAME IS REX AND I LIKE S_M_TH_NG!"</pre>
  
  Ruby's inheritance system is more powerful than simply calling methods in parent classes.
  For more information on how it works, refer to the "inheritance article":/inheritance.html.
  
  h3. Modifying existing classes
  
  You can add methods to classes after you've created them using a couple of special methods.
  All classes created using @JS.Class@ have these methods, the first of which is @define()@.
  This adds a single named method to the class, which immediately makes it available in
  instances of the class and in its subclasses.
  
  <pre class="prettyprint">
  Animal.define('sleep', function() {
    return this.name + ' is sleeping';
  });
  
  rex.sleep()
  // -> "Rex is sleeping"</pre>
  
  Note that if the class already has a method with the same name as the one you're defining,
  the old method will be overwritten. Methods in parent classes and in mixins can be accessed
  using @callSuper()@.
  
  The other option available to you is to use @include()@. This method has a couple of roles;
  if you supply a "@Module@":/modules.html, the module is mixed into the class and becomes
  part of its inheritance tree. If you supply any other type of object, the methods from the
  object are copied into the class, overwriting any pre-existing methods with similar names.
  
  <pre class="prettyprint">
  // Replace Dog's speak method  (#1)
  Dog.include({
    speak: function(stuff) {
      return this.callSuper('lots of ' + stuff) + '!';
    }
  });
  
  rex.speak('cats')
  // -> "My name is Rex and I like lots of cats!"
  
  // Mix in a module, altering the class's ancestry
  // callSuper() in Dog#speak will now call this method
  var Speaker = new JS.Module({
    speak: function(stuff) {
      return 'I can talk about ' + stuff + '!';
    }
  });
  
  Dog.include(Speaker);
  rex.speak('cats')
  // -> "I can talk about lots of cats!!"</pre>
  
  Notice how including @Speaker@ does not overwrite the @speak@ method in the @Dog@ class
  (marked @#1@ above). That method is defined in @Dog@ and will persist until overwritten
  directly in the @Dog@ class. @Speaker@ merely injects another method called @speak@ into
  the inheritance chain for the @Dog@ class. For more information, refer to the "explanation
  of Ruby's method lookup algorithm":/inheritance.html.
