:textile
  h3. @JS.Packages@
  
  @JS.Class@, as of version 2.0, comes with a package system that lets you load scripts
  on demand with support for dependency management. Its lets you name objects and the URLs
  for the files that contain them, so your application code only has to deal with knowing
  which objects it needs, not where to find those objects. Where possible, @JS.Package@
  will download scripts in parallel to improve load speed, and it makes sure interdependent
  scripts are loaded in the correct order. It uses script tag injection rather than
  @XMLHttpRequest@, so it works cross-domain.
  
  For example, say I want to do something with "YUI's CSS selector":http://developer.yahoo.com/yui/selector/.
  I just need to @require@ it, and supply a function to run once all the requisite code
  has loaded:
  
  <pre class="prettyprint">    require('YAHOO.util.Selector', function() {
          var myDivs = YAHOO.util.Selector.query('div.mine');
          // .. more code (elided)
      });</pre>
  
  h3. Setting up
  
  Before you can use the @require@ statement, you need the following loaded into the
  page:
  
  * The @JS.Class@ core (@class.js@)
  * @JS.Package@, the dependency manager (@package.js@)
  * A list of dependencies
  
  The first two are dealt with with a couple of @script@ tags. The third needs to be
  written out to describe all the other files in your application and how they relate
  to each other.
  
  h3. The package listing
  
  To describe your packages, you list the external script files used by your application,
  stating which JavaScript objects are provided by the file and which objects it depends
  on. For example, here's a typical package definition for "YUI":http://developer.yahoo.com/yui/:
  
  <pre class="prettyprint">    JS.Packages(function() { with(this) {
          var cdn  = 'http://yui.yahooapis.com/';
          var yui  = cdn + '2.7.0/build/';
          
          file(yui + 'yahoo-dom-event/yahoo-dom-event.js')
              .provides('YAHOO',
                        'YAHOO.lang',
                        'YAHOO.util.Dom',
                        'YAHOO.util.Event');
          
          file(yui + 'selector/selector-min.js')
              .provides('YAHOO.util.Selector')
              .requires('YAHOO');
          
          file(yui + 'animation/animation-min.js')
              .provides('YAHOO.util.Anim',
                        'YAHOO.util.ColorAnim')
              .requires('YAHOO');
          
          file(yui + 'dragdrop/dragdrop-min.js')
              .provides('YAHOO.util.DD')
              .requires('YAHOO',
                        'YAHOO.util.Dom');
          
          file(yui + 'slider/slider-min.js')
              .provides('YAHOO.widget.Slider')
              .requires('YAHOO',
                        'YAHOO.util.Anim',
                        'YAHOO.util.DD');
      }});</pre>
  
  (Yes, YUI has its own loader utility, I'm just using this as a well-known example.)
  
  Notice how two of the stated dependencies for @YAHOO.util.DD@ are provided by the same
  file - @YAHOO@ and @YAHOO.util.Dom@. The package system will spot this and only loads
  each file once. Object detection is used to figure out whether each file has been loaded
  and a file is not requested unless some of its objects appear to be missing.
  
  Where possible, the package system will attempt to load scripts in parallel where it
  spots that execution order doesn't matter. If the load order of a set of scripts is
  important, you must *make sure you make this clear using the @requires()@ statement*.
  A file will not be requested until all the objects it @requires@ are present.
  
  h3. Custom loader functions
  
  Some libraries, such as the "Google Ajax APIs":http://code.google.com/apis/ajax/,
  have their own systems for loading code on demand that involve more than simply
  knowing the path to a script file. Our package system allows you to specify packages
  that use a loader function rather than a path to load themselves; the function should
  take a callback and call it when the library in question is done loading. For exmaple,
  here's how you'd incorporate Google Maps into your library:
  
  <pre class="prettyprint">    JS.Packages(function() { with(this) {
      
          file('http://www.google.com/jsapi?key=MY_GOOGLE_KEY')
              .provides('google.load');
          
          loader(function(cb) {
              google.load('maps', '2.x', {callback: cb});
          })  .provides('GMap2',
                        'GClientGeocoder')
              .requires('google.load');
      }});</pre>
  
  The callback (@cb@) is a function generated by the package system that continues
  to load and run dependent code once the custom loader has finished its work. If you
  don't call @cb@ (or pass it to a function that will call it for you as above), code
  that depends on this library will not run.
  
