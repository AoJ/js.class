:textile
  h3. @JS.Test@
  
  JS.Class includes a testing framework called @JS.Test@. You can use it
  to test any JavaScript code, not just programs written with JS.Class,
  and it's designed to run on a wide variety of platforms without
  configuration. In combination with "@JS.Packages@":/packages.html it
  makes it really easy to organise and run your test suite in a way that
  works cross-platform. It runs without configuration on all of JS.Class's
  "supported platforms":/platforms.html.
  
  h3. Getting started
  
  We'll start with a simple tutorial to test-drive some code using
  "Node.js":http://nodejs.org/. Let's create a directory structure to
  host our new project:
  
  <pre>    project/
          source/
          test/
              specs/
              run.js
          vendor/
              jsclass/
                  core.js
                  package.js
                  test.js
                  (etc)</pre>
  
  @JS.Test@ does not require any particular project layout, but I tend to
  lay out my files like this. Our @source@ directory contains the source
  code for the project we're building. The @test/specs@ directory contains
  a spec file for each source file; this is where we'll be writing our tests.
  Finally, @test/run.js@ is the script we'll run from the command line or
  load into a browser; its job is to load up all our code and tests and run
  the test suite.
  
  Let's add some code to @run.js@. We need to load the JS.Class framework,
  tell it where to find our tests, then run the test suite.
  
  <pre class="prettyprint">    // test/run.js
      
      JSCLASS_PATH = 'vendor/jsclass';
      require('../' + JSCLASS_PATH + '/loader');

      JS.Packages(function() { with(this) {
          autoload(/.*Spec$/, {from: 'test/specs'});
      }});

      JS.require('JS.Test', function() {
          JS.require('UserSpec', JS.Test.method('autorun'));
      });</pre>
  
  That @autoload@ statement tells @JS.Packages@ it should look for any
  object whose name matches @/.*Spec$/@ in the @test/specs@ directory, for
  example @UserSpec@ should be in @test/specs/user_spec.js@. Finally we
  load @JS.Test@, then load our specs and use the @JS.Test.autorun()@ method
  to run them all.
  
  Let's try running it:
  
  <pre>    ~/project $ node test/run.js
      Error: Cannot find module 'test/specs/user_spec'</pre>
  
  We've not created the spec file yet, so Node is complaining. Create a
  blank file at that path, then run the tests again:
  
  <pre>    ~/project $ touch test/specs/user_spec.js
      ~/project $ node test/run.js
      Error: Expected package at test/specs/user_spec.js to define UserSpec</pre>
  
  This error happens because @test/specs/user_spec.js@ doesn't contain any
  code yet: the next step is to start writing this spec.
  
  h3. Writing specs
  
  Specs are organized using the nested context style popularized by RSpec.
  Contexts are delimited using the @describe@ method, and each test is created
  using the @it@ method. Within each context we can use @before@ and @after@
  hooks to set up and tear down any state the tests need. Assigning properties
  to @this@ in a @before@ block makes them appear as local variables in the
  tests.
  
  Let's write a simple spec for our @User@ class.
  
  <pre class="prettyprint">    // test/specs/user_spec.js
      
      JS.ENV.UserSpec = JS.Test.describe('User', function() {
          before(function() {
              this.user = new User('James');
          });

          it('has a name', function() {
              assertEqual('James', user.getName());
          });
      });</pre>
  
  We need to make @UserSpec@ a global variable so that @JS.Packages@ can
  find it. Accessing the global scope requires different code on different
  platforms, but you can use @JS.ENV@ to refer to it across all platforms.
  
  If we run the test again we start to get meaningful output:
  
  <pre>    ~/project $ node test/run.js 
      Loaded suite User
      Started
      EE
      Finished in 0.032 seconds.

      1) Error:
      test: User has a name:
      ReferenceError: User is not defined

      2) Error:
      test: User has a name:
      ReferenceError: user is not defined

      1 tests, 0 assertions, 0 failures, 2 errors</pre>
  
  We've got two errors, one from the before block because the @User@ class
  doesn't exist, and one from the test because the @user@ variable was
  never created. To fix this, we need to create the class, and tell
  @JS.Packages@ where to find it. Add this code to @source/user.js@:
  
  <pre class="prettyprint">    // source/user.js
      JS.ENV.User = new JS.Class('User');</pre>
  
  Change @test/run.js@ to say that @UserSpec@ requires @User@, and tell
  it where to find the @User@ class:
  
  <pre class="prettyprint">    // test/run.js
      
      JS.Packages(function() { with(this) {
          autoload(/^(.*)Spec$/, {from: 'test/specs', require: '$1'});
          
          file('source/user.js')
              .provides('User')
              .requires('JS.Class');
      }});</pre>
  
  Let's run our tests again:
  
  <pre>    ~/project $ node test/run.js
      Loaded suite User
      Started
      E
      Finished in 0.035 seconds.

      1) Error:
      test: User has a name:
      TypeError: Object #<User:4d28a88f> has no method 'getName'

      1 tests, 0 assertions, 0 failures, 1 errors</pre>
  
  Just one error this time: our class doesn't have the method we're
  testing. Let's finish writing our class so it passes the tests:
  
  <pre class="prettyprint">    // source/user.js
      
      JS.ENV.User = new JS.Class('User', {
          initialize: function(name) {
              this._name = name;
          },

          getName: function() {
              return this._name;
          }
      });</pre>
  
  One last test run:
  
  <pre>    ~/project $ node test/run.js 
      Loaded suite User
      Started
      .
      Finished in 0.038 seconds.

      1 tests, 1 assertions, 0 failures, 0 errors</pre>
  
  Finally we've got a passing test. We can continue adding tests like
  this to build up our project. See the list of assertions below; they
  offer a rich set of tests to verify the behaviour of your code.
  
  h3. Running on other platforms
  
  So far we've been running our tests with Node. But what happens if we
  run them with another tool, say "Rhino":http://www.mozilla.org/rhino/?
  
  <pre>    ~/project $ rhino test/run.js 
      js: uncaught JavaScript runtime exception:
      ReferenceError: "require" is not defined.</pre>
  
  Rhino (and other shells like V8 and SpiderMonkey) don't support the
  @require()@ function to load files, they use @load()@. Let's change
  @test/run.js@ to accommodate this:
  
  <pre class="prettyprint">    // test/run.js
      
      if (typeof require === 'function') {
          require('../' + JSCLASS_PATH + '/loader');
      } else {
          load(JSCLASS_PATH + '/loader.js');
      }</pre>
  
  Now you should be able to run the tests on Rhino, V8, SpiderMonkey,
  Narwhal and Node. You don't need to change any other code; @JS.require()@
  works across platforms so you only need to change the code that loads
  JS.Class initially.
  
  However, some platforms such as RingoJS don't add variables assigned
  without @var@ to the global scope. @JSCLASS_PATH@ must be a global variable
  but we don't yet have @JS.ENV@ loaded to help us out. If you want to run
  on these platforms, change your @JSCLASS_PATH@ line to the following:
  
  <pre class="prettyprint">    // test/run.js
      
      (function() {
          var $ = (typeof this.global === 'object') ? this.global : this;
          $.JSCLASS_PATH = 'vendor/jsclass';
      })();</pre>
  
  Your tests will not run a wide range of server-side platforms, but
  not on Windows Script Host. If you need to support this platform, you
  need to define a @load()@ function before doing anything else. Your
  final @test/run.js@ file will look like this, at which point it will
  run on all supported platforms:
  
  <pre class="prettyprint">    // test/run.js
      
      if (this.ActiveXObject)
          load = function(path) {
              var fso = new ActiveXObject('Scripting.FileSystemObject'),
                  file, runner;
              
              try {
                  file   = fso.OpenTextFile(path);
                  runner = function() { eval(file.ReadAll()) };
                  runner();
              } finally {
                  try { if (file) file.Close() } catch (e) {}
              }
          };

      (function() {
          var $ = (typeof this.global === 'object') ? this.global : this;
          $.JSCLASS_PATH = 'vendor/jsclass';
      })();

      if (typeof require === 'function') {
          require('../' + JSCLASS_PATH + '/loader');
      } else {
          load(JSCLASS_PATH + '/loader.js');
      }

      JS.Packages(function() { with(this) {
          autoload(/^(.*)Spec$/, {from: 'test/specs', require: '$1'});
          file('source/user.js').provides('User');
      }});

      JS.require('JS.Test', function() {
          JS.require('UserSpec', JS.Test.method('autorun'));
      });</pre>
  
  h3. Running in the browser
  
  To run our tests in a web browser we need a web page to host the tests,
  and we need to separate the test-running code from the server-side
  framework-loading code. Take the platform-dependent code out of @test/run.js@
  and put it in @test/console.js@. We're also going to add a constant called
  @CWD@ (for 'current working directory') since browsers have no concept
  of a working directory and we need to specify where the root of the project
  is relative to the test page.
  
  You should have two files that look like this:
  
  <pre class="prettyprint">    // test/console.js
      
      // ... WSH load() function if necessary ...
      
      (function() {
          var $ = (typeof this.global === 'object') ? this.global : this;
          $.JSCLASS_PATH = 'vendor/jsclass';
      })();

      if (typeof require === 'function') {
          require('../' + JSCLASS_PATH + '/loader');
          require('./run');
      } else {
          load(JSCLASS_PATH + '/loader.js');
          load('test/run.js');
      }</pre>
  
  <pre class="prettyprint">    // test/run.js
      
      var CWD = (typeof CWD === 'undefined') ? '.' : CWD;
      
      JS.Packages(function() { with(this) {
          autoload(/^(.*)Spec$/, {from: CWD + '/test/specs', require: '$1'});
          file(CWD + '/source/user.js').provides('User');
      }});

      JS.require('JS.Test', function() {
          JS.require('UserSpec', JS.Test.method('autorun'));
      });</pre>
  
  You should still be able to run the tests using @node test/console.js@
  in the terminal. Now we just set up a web page that does the same job
  as @test/console.js@, but in the browser:
  
  <pre class="prettyprint">    <!-- test/browser.html -->
  
      <!doctype html>
      <html>
          <head>
              <meta http-equiv="Content-type" content="text/html; charset=utf-8">
              <title>Test runner</title>
          </head>
          <body>
              <script type="text/javascript">CWD = '..'</script>
              <script type="text/javascript" src="../vendor/jsclass/loader.js"></script>
              <script type="text/javascript" src="../test/run.js"></script>
          </body>
      </html></pre>
  
  Save this as @test/browser.html@ and open it in any browser to see the
  test results.
  
  When running in the browser, @JS.Test@ will automatically notify
  "TestSwarm":http://www.testswarm.com/ if you're using it, so you can
  easily use @JS.Test@ for your continuous integration setup.
  
  h3. Assertions
  
  Within each test, you can use any of these functions to check the output
  of your program. If an assertion fails, no further code in that test is
  run.
  
  * @assertBlock([message, ]callback)@ passes if the @callback@ function
    returns a truthy value. @message@ is an optional parameter, as it is
    for all other assertions, and if given should be a string that will be
    used when printing an error message if the assertion fails.
  * @assert(boolean[, message])@ passes if the expression @boolean@ has
    a truthy value.
  * @assertEqual(expected, actual[, message])@ passes if @expected@
    and @actual@ are equal. "Equality":/equality.html is determined using
    the @equals()@ method if @expected@ responds to it, and the @===@
    operator otherwise. This assertion also handles deep-equality of arrays
    and objects, comparing the elements of the object using @equals()@ or
    @===@ where appropriate.
  * @assertNotEqual(expected, actual[, message])@ passes if @expected@
    and @actual@ are not equal according to the semantics of @assertEqual()@.
  * @assertSame(expected, actual[, message])@ passes if @expected@ and
    @actual@ are the same object, i.e. @expected === actual@.
  * @assertNotSame(expected, actual[, message])@ passes if @expected@ and
    @actual@ are not the same object, i.e. @expected !== actual@.
  * @assertInDelta(expected, actual, delta[, message])@ passes if
    @|expected - actual| <= delta@. All values must be numbers.
  * @assertKindOf(type, object[, message])@ passes if @object@ is an
    instance of @type@. @type@ can be a JavaScript type string like
    @'boolean'@ or @'object'@, or a reference to a class or module.
  * @assertMatch(pattern, string[, message])@ passes if @string@ matches
    the regular expression @pattern@. This can also be used with any object
    that responds to @match()@ as the pattern, for example
    @assertMatch(new JS.Range(1,10), 5)@.
  * @assertNoMatch(pattern, string[, message])@ passes if @pattern@ does
    not match @string@ (inverse of @assertMatch@).
  * @assertNull(object[, message])@ passes if @object@ is @null@.
  * @assertNotNull(object[, message])@ passes if @object@ is not @null@.
  * @assertRespondTo(object, method[, message])@ passes if @object@
    has a property or method named @method@.
  * @assertThrows(error[, error2], callback)@ passes if calling the
    given @callback@ function throws one of the given error types, for
    example @assertThrows(TypeError, function() { null.foo() })@.
  * @assertNothingThrown([error, ][message, ]callback)@ passes if calling
    the given @callback@ does not throw an error, for example
    @assertNothingThrown(function() { 1 + 1 })@. You can specify what
    types of errors should be caught, for example
    @assertNothingThrown(TypeError, ReferenceError, function() { 1 + 1 })@;
    if the @callback@ throws any other type of error this will be reported
    as an error rather than a test failure.

