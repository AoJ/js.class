:textile
  h3. Inheritance
  
  To understand Ruby's inheritance model, you need to know how it performs method
  name lookup. This explanation comes from "_The Ruby Programming Language_":http://www.amazon.co.uk/Ruby-Programming-Language-David-Flanagan/dp/0596516177/ref=sr_1_1?ie=UTF8&s=books&qid=1215018362&sr=8-1 by David Flanagan and Yukihiro
  Matsumoto (the author of Ruby itself):
  
  <blockquote cite="http://www.amazon.co.uk/Ruby-Programming-Language-David-Flanagan/dp/0596516177/ref=sr_1_1?ie=UTF8&s=books&qid=1215018362&sr=8-1">
    <p>When Ruby evaluates a method invocation expression, it must first figure out
    which method is to be invoked. The process for doing this is called method
    lookup or method name resolution. For the method invocation expression @o.m@,
    Rub performs name resolution with the following steps:</p>
    
    <ol>
    <li>First, it checks the eigenclass of @o@ for singleton methods named @m@.</li>
    <li>If no method @m@ is found in the eigenclass, Ruby searches the class of @o@
      for an instance method named @m@.</li>
    <li>If no method @m@ is found in the class, Ruby searches the instance methods
      of any modules included by the class of @o@. If that class includes more than
      one module, then they are searched in the reverse of the order in which they
      were included. That is, the most recently included module is searched first.</li>
    <li>If no instance method @m@ is found in the class of @o@ or in its modules, then
      the search moves up the inheritance hierarchy to the superclass. Steps 2 and
      3 are repeated for each class in the inheritance hierarchy until each ancestor
      class and its included modules have been searched.</li>
    </ol>
  </blockquote>
  
  
